---
title: "Statistical Rethinking Ch. 2"
author: "Jacob Longmeyer"
date: "2026-01-14"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Many things are needed for setup:
```{r}
library(rstan)
library(coda)
library(mvtnorm)
library(devtools)
library(dagitty)
library(rethinking)
library(ggdist)

##apparently I was successful in downloading it
##devtools::install_github("rmcelreath/rethinking")
```


# In Text Examples

```{r}
#define grid
p_grid <- seq( from=0, to=1, length.out=100)

#define prior, with alternative priors
prior <- rep(1,20)
prior <- ifelse( p_grid <0.5, 0, 1)
prior <- exp( -5*abs(p_grid - 0.5))

#compute likelihood at each value in grid
likelihood <- dbinom( 6, size = 9, prob=p_grid)

#compute product of likelihood and prior
unstd.posterior <-  likelihood * prior

#standardize the posterior, so it sum to 1
posterior <- unstd.posterior / sum(unstd.posterior)

#display post dist
plot(p_grid, posterior, type="b", #type b is points and lines
     xlab = "probability of water", ylab="posterior probability")
mtext("20 points")
```
The basic workflow is to set your p_grid number
Define prior
Define likelihood by calculating dbinom with prob = p_grid
Then multiply likelihood and prior to get unstandardized posterior
Then standardize the posterior
type argument in plot. l = lines, b = points and lines, c = empty points and lines, o = overplotted points and lines, s = stairsteps, h = histogram-like vertical lines, n = nothing

I was curious about the statement that the logarithm of a normal Gaussian distribution is a parabola, so look below:
```{r}
###prove that the logarithm of a normal (Gaussian) distribution is a parabola,
#described by the quadratic equation (a la Chat GPT)
# Normal curve
x <- seq(-4, 4, length=100)
f <- dnorm(x, mean=0, sd=1)
plot(x, f, type='l', main='Normal Distribution')

# Log-Normal curve
logf <- log(f)
plot(x, logf, type='l', main='Log of Normal Distribution') # <-- Looks like a parabola
```

Quadratic Approximation Method
```{r}
###R Code 2.6
globe.qa <- quap(
  alist(
    W ~ dbinom( W+L, p) , #binomial likelihood
    p ~ dunif(0,1)        #uniform prior
  ) ,
data=list(W=6, L=3))

#display summary of quadratic approximation
precis(globe.qa)
```

To use quap, you provide a formula, a list of data. The formula defines the probability of the data and the prior. This will be revisited in Ch. 4.

In the example above, the posterior mean value of p = 0.67, which it calls the mean. The curvatur is labeled StdDev, or the standard deviation, which is enough to define the Gaussian dist.

Also didn't get to the code for MCMC technhiques, which is in code blocks 2.8 and 2.9.

# Chapter Exercises

## 2E1.
The correct answer is 2, and apparently also 4, which I assume requires some math of conditional probabilities, which I do not know how to do. I did some looking and lo and behold:

P(A, B) = P(A) * P(B|A)

This can be reworked:

P(B|A) = P(A,B) / P(A) 

This is equivalent to option 4, which is why it is also correct.

## 2E2.
3

## 2E3.
1 & 4
4 is correct because it is just Baye's Theorem

## 2E4.
Probabilities are not something that exist, but rather describe our expectation given what we know at that point. Thus, we expect that the proportion of waters will be 0.7 but it is very unlikely to come out to be exactly that.

## 2M1.
```{r}
#define grid
p_grid <- seq(from = 0, to = 1, length.out = 100)

#define prior
prior <- rep(1, times = 100)

#define likelihood
likelihood <- dbinom(3,size = 3,prob = p_grid)


#get unstd posterior
unstd.posterior <- prior * likelihood

#standardize posterior
posterior <- unstd.posterior / sum(unstd.posterior)

#plot
plot(p_grid, posterior, type = "b",
     xlab = "probability of water", ylab = "posterior probability")

#redo the necessary parts for parts 2 and 3
likelihood2 <- dbinom(3, size = 4, prob = p_grid)
likelihood3 <- dbinom(5, size = 7, prob = p_grid)
posterior2 <- (prior * likelihood2) / sum(prior * likelihood2)
posterior3 <- (prior * likelihood3) / sum(prior * likelihood3)

plot(p_grid, posterior2, type = "b") #3 out of 4
plot(p_grid, posterior3, type = "b") #5 out of 7
```

## 2M2.
```{r}
#create new prior from last problem
prior2 <- ifelse(p_grid < 0.5, 0, 1)

# first set of observations: W, W, W
likelihood1 <- dbinom(3,size = 3,prob = p_grid)
posterior1 <- (prior2 * likelihood1) / sum(prior2 * likelihood1)
plot(p_grid, posterior1, type = "b")

#second set: W, W, W, L
likelihood2 <- dbinom(3, size = 4, prob = p_grid)
posterior2 <- (prior2 * likelihood2) / sum(prior2 * likelihood2)
plot(p_grid, posterior2, type = "b") #3 out of 4

#third set: L, W, W, L, W, W, W
likelihood3 <- dbinom(5, size = 7, prob = p_grid)
posterior3 <- (prior2 * likelihood3) / sum(prior2 * likelihood3)
plot(p_grid, posterior3, type = "b") #5 out of 7
```

## 2M3.
This problem is asking:
Pr(Earth|L)

We know:
Pr(Earth) = 0.5
Pr(Mars) = 0.5
Pr(L|Earth) = 0.3
Pr(L|Mars) = 1

Baye's Theorem
Pr(A|B) = Pr(B|A)Pr(A) / Pr(B)

Pr(Earth|L) = Pr(L|Earth)Pr(Earth) / Pr(L)
Pr(Earth|L) = 0.3 * 0.5 / Pr(L)

Pr(L) = Pr(Earth) * Pr(L|Earth) + Pr(Mars) * Pr(L|Mars)
Pr(L) = 0.5 * 0.3 + 0.5 * 1 = 0.65

Therefore...
Pr(Earth|L) = (0.3 * 0.5) / 0.65 = 0.231

## 2M4.
This problem is asking: Pr(other side black | black drawn)

Because of this, you can get rid of card 3 from calculations because it cannot produce the given situation. You can also get rid of the case where you pull the white side of card 2. This leaves 3 possibilities. You pull the black side of card two, or your pull card 1. In two cases, the other side will be black, in the third case, it will be white. Therefore the probability that the other side is black is 2/3.

I drew a diagram for this on scrap paper, but it cannot be shown here.

Another way to address the problem:
```{r}
bb_likelihood <- 2
bw_likelihood <- 1
ww_likelihood <- 0

likelihood <- c(bb_likelihood, bw_likelihood, ww_likelihood)
prior <- rep(1,3)
posterior <- (likelihood * prior) / sum(likelihood*prior)

# posterior probability of choosing a double sided black card
posterior[1]
```


## 2M5.
```{r}
likelihood <- c(bb_likelihood, bw_likelihood, ww_likelihood, bb_likelihood)
prior <- rep(1,4)
posterior <- likelihood * prior
posterior <- posterior / sum(posterior)

#posterior probability of correct card is added probability of cards 1 and 4
posterior[1] + posterior[4]
```

## 2M6.
```{r}
likelihood <- c(bb_likelihood, bw_likelihood, ww_likelihood)
prior <- c(1, 2, 3) #our prior corresponds to the ways to pull cards based on weight
posterior <- (likelihood * prior) / sum(likelihood*prior)

# posterior probability of choosing a double sided black card
posterior[1]
```

## 2M7.
This problem is asking Pr(draw double black card | white face on second card drawn)

I drew out the forking diagram and was able to do it this way, and basically I think it's better to just do it that way instead of typing it out in code.

```{r}
bw_ww <- 1 * 2 #ways of getting the situation when drawing bw card then ww card
bb_bw <- 2 * 1 #ways when drawing bb card then bw card
bb_ww <- 2 * 2 #ways when drawing bb card then ww card

likelihood <- c(bw_ww, bb_bw, bb_ww)
prior <- c(1, 1, 1)
posterior <- prior * likelihood
posterior <- posterior / sum(posterior)

#probability of getting the double black card is equal to sum of second and third 
posterior[2] + posterior[3]
```


